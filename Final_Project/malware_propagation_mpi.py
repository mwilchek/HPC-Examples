from collections import namedtuple
from mpi4py import MPI
import random
import sys
import math
import time
import copy
import numpy as np

''' This script simulates malware propagation from bluetooth enabled devices using a Cellular Automata Model. 
For more information please go here: http://www.ijcncs.org/published/volume3/issue3/p1_3-3.pdf '''

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()
stat = MPI.Status()

print("First Generation for rank: " + str(rank))

# sets how many devices in location; set to 100%
Dinit = 1
NX = 50 + 2
NY = 50
generations = 50  # also will be treated as t for step 6

# Setup subgrid for MPI Parallelization #######################################
if size > NX:
    print("Not enough ROWS")
    exit()

subROWS = NX // size + 2

# Transmission Threshold (TR) is the probability which a node transforms from state V to other states
TR = .5
# End of step 5 has logic if mobile device is charged or is being charged (not included)
phone_power = 100
SR = -1

# Refer to page 5 of probability parameters & page 7 for simulation
MobilePhone = namedtuple('Mobile', 'STATE D HV VI VE EI IQ QI ER ID DR VR')
tnew = []
start = time.time()


def printf(format, *args):
    sys.stdout.write(format % args)


def showCellPhones(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if newSubGrid[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif newSubGrid[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif newSubGrid[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Infectious State (Red)
            elif newSubGrid[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif newSubGrid[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Recovered State (Green)
            elif newSubGrid[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Quiet State (White)
            elif newSubGrid[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', newSubGrid[i][j].STATE)
        printf("\n")
    printf('\x1b[2J\x1b[H')

    time.sleep(1)


def showCellPhones_persist(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if newSubGrid[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif newSubGrid[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif newSubGrid[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Infectious State (Red)
            elif newSubGrid[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif newSubGrid[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Recovered State (Green)
            elif newSubGrid[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            # If node is in Quiet State (White)
            elif newSubGrid[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', newSubGrid[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', newSubGrid[i][j].STATE)
        printf("\n")


for i in range(NY):
    new = []
    for j in range(NX):
        # Instantiate nodes with the following:
        # STATE is empty, distribution is random, prob from Healthy to Vulnerable,

        # Probabilities:                             HV   VI   VE   EI   IQ   QI   ER   ID   DR   VR
        # Parameters from paper:                    0.5, 0.6, 0.0, 0.2, 0.0, 0.15, 0.4, 0.5, 0.4, 0.1
        # Custom parameters 1:                      0.5, 0.8, 0.0, 0.8, 0.2, 0.8, 0.02, 0.1, 0.4, 0.1
        # Custom parameters 2:                      0.5, 0.5, 0.4, 0.6, 0.5, 0.7, 0.1,  0.3, 0.3, 0.1
        Node = MobilePhone(' ', random.random(), 0.5, 0.5, 0.4, 0.6, 0.5, 0.7, 0.1, 0.3, 0.3, 0.1)

        new.append(Node)
    tnew.append(new)

# Initialize mobile phone network
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0:
            tnew[i][j] = tnew[i][j]._replace(STATE='H')

# Infect a device in the middle of the grid */
# Constant source infected */ //	tnew[nx/2][ny/2].B = 1;
tnew[NY // 2][NX // 2] = tnew[NY // 2][NX // 2]._replace(STATE='I')  # changes center device to infected in location

# Show initial state
showCellPhones(NX, NY, tnew)

# Set all other healthy nodes to Vulnerable now 1 device is infected
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0 and tnew[i][j].STATE != 'I':
            tnew[i][j] = tnew[i][j]._replace(STATE='V')

# Show vulnerable state
showCellPhones(NX, NY, tnew)

subGrid = np.reshape(tnew, (subROWS, NY))
newSubGrid = np.copy(subGrid)


# Function definitions
def msgUp():
    comm.send(subGrid[subROWS - 2, :], dest=rank + 1)
    subGrid[subROWS - 1, :] = comm.recv(source=rank + 1)
    return 0


def msgDown():
    comm.send(subGrid[1, :], dest=rank - 1)
    subGrid[0, :] = comm.recv(source=rank - 1)
    return 0


def spreadMalware():
    global subGrid
    #    print(id(t),id(tnew),id(t[0]),id(tnew[0]),id(new),id(t[0][0]))
    for i in range(1, NY - 1):
        for j in range(1, subROWS - 1):
            # Rules of the game ################ PRIMARY CONDITIONAL CHECK ###################
            # Breaking out step 5 on page 7

            # Node x is (i,j)
            # Count number of infected neighbors (IC) around x node
            IC = 0
            if subGrid[i + 1][j + 1].STATE == 'I':
                IC += 1
            elif subGrid[i - 1][j + 1].STATE == 'I':
                IC += 1
            elif subGrid[i + 1][j - 1].STATE == 'I':
                IC += 1
            elif subGrid[i - 1][j - 1].STATE == 'I':
                IC += 1
            elif subGrid[i - 1][j].STATE == 'I':
                IC += 1
            elif subGrid[i][j - 1].STATE == 'I':
                IC += 1
            elif subGrid[i][j + 1].STATE == 'I':
                IC += 1
            elif subGrid[i + 1][j].STATE == 'I':
                IC += 1

            # Check if node x is Exposed
            if subGrid[i][j].STATE == 'E':
                # Check if node x changes from E to R with probability of ER
                if newSubGrid[i][j].ER > random.random():
                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='R')
                # Or node x changes from E to I with probability of EI + ER
                elif newSubGrid[i][j].EI + newSubGrid[i][j].ER > random.random():
                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='I')

            # Check if node x is Diagnosed
            if subGrid[i][j].STATE == 'D':
                # Check if node x changes from D to R with probability of DR
                if newSubGrid[i][j].DR > random.random():
                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='R')

            # Check if x node is infected
            if subGrid[i][j].STATE == 'I':
                # Calculate Spread Rate (SR), Resistance Rate (RR), Node Distance (D), and Beta (b) for each X node

                # Does a corner node exist?
                if 0.293 > random.random():
                    # If the state of its neighbor node y is V
                    # Check node diagonally to the upper right if it exists
                    try:
                        if subGrid[i + 1][j + 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i + 1][j + 1].VE > random.random():
                                    newSubGrid[i + 1][j + 1] = newSubGrid[i + 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i + 1][j + 1].VR > random.random():
                                    newSubGrid[i + 1][j + 1] = newSubGrid[i + 1][j + 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i + 1][j + 1] = newSubGrid[i + 1][j + 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')

                    except IndexError:
                        pass

                    # Check node diagonally to the upper left if it exists
                    try:
                        if subGrid[i - 1][j + 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i - 1][j + 1].VE > random.random():
                                    newSubGrid[i - 1][j + 1] = newSubGrid[i - 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i - 1][j + 1].VR > random.random():
                                    newSubGrid[i - 1][j + 1] = newSubGrid[i - 1][j + 1]._replace(STATE='R')

                                # Added
                                else:
                                    newSubGrid[i - 1][j + 1] = newSubGrid[i - 1][j + 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower right if it exists
                    try:
                        if subGrid[i + 1][j - 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i + 1][j - 1].VE > random.random():
                                    newSubGrid[i + 1][j - 1] = newSubGrid[i + 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i + 1][j - 1].VR > random.random():
                                    newSubGrid[i + 1][j - 1] = newSubGrid[i + 1][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i + 1][j - 1] = newSubGrid[i + 1][j - 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower left if it exists
                    try:
                        if subGrid[i - 1][j - 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i - 1][j - 1].VE > random.random():
                                    newSubGrid[i - 1][j - 1] = newSubGrid[i - 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i - 1][j - 1].VR > random.random():
                                    newSubGrid[i - 1][j - 1] = newSubGrid[i - 1][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i - 1][j - 1] = newSubGrid[i - 1][j - 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass
                # If this, then it only checks to the left, right, above and below of x node
                else:

                    # Check node to the left if it exists
                    try:
                        if subGrid[i - 1][j].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i - 1][j].VE > random.random():
                                    newSubGrid[i - 1][j] = newSubGrid[i - 1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i - 1][j].VR > random.random():
                                    newSubGrid[i - 1][j] = newSubGrid[i - 1][j]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i - 1][j] = newSubGrid[i - 1][j]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the below if it exists
                    try:
                        if subGrid[i][j - 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i][j - 1].VE > random.random():
                                    newSubGrid[i][j - 1] = newSubGrid[i][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i][j - 1].VR > random.random():
                                    newSubGrid[i][j - 1] = newSubGrid[i][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i][j - 1] = newSubGrid[i][j - 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the above if it exists
                    try:
                        if subGrid[i][j + 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i][j + 1].VE > random.random():
                                    newSubGrid[i][j + 1] = newSubGrid[i][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i][j + 1].VR > random.random():
                                    newSubGrid[i][j + 1] = newSubGrid[i][j + 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i][j + 1] = newSubGrid[i][j + 1]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the right if it exists
                    try:
                        if subGrid[i + 1][j].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if newSubGrid[i + 1][j].VE > random.random():
                                    newSubGrid[i + 1][j] = newSubGrid[i + 1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if newSubGrid[i + 1][j].VR > random.random():
                                    newSubGrid[i + 1][j] = newSubGrid[i + 1][j]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    newSubGrid[i + 1][j] = newSubGrid[i + 1][j]._replace(STATE='I')

                                if newSubGrid[i][j].ID > random.random():
                                    newSubGrid[i][j] = newSubGrid[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

    subGrid = np.copy(newSubGrid)


# The main body of the algorithm
# compute new grid and pass rows to neighbors
# t is now subGrid and tnew is now newSubGrid
for step in range(generations):
    print("Starting Round: " + str(step))
    subGrid = copy.deepcopy(newSubGrid)

    # exchange edge rows for next iteration
    if rank == 0:
        msgUp()
    elif rank == size - 1:
        msgDown()
    else:
        msgUp()
        msgDown()

    spreadMalware()

    mainGrid = comm.allgather(subGrid[1:subROWS - 1, :])
    mainGrid = np.asarray(mainGrid)

    finalGrid = comm.gather(subGrid[1:subROWS - 1, 1:NY - 1], root=0)

    # Increase time += 1 for each generation as specified in step 6 on page 7
    showCellPhones(NX, NY, finalGrid)

finalGrid = comm.gather(subGrid[1:subROWS - 1, 1:NY - 1], root=0)

if rank == 0:
    showCellPhones_persist(NX, NY, finalGrid)
    end = time.time()
    print("Total Execution Time: " + str((end - start)))
