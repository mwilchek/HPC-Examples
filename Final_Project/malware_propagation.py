from collections import namedtuple
import random
import sys
import math
import time
import copy

''' This script simulates malware propagation from bluetooth enabled devices using a Cellular Automata Model. 
For more information please go here: http://www.ijcncs.org/published/volume3/issue3/p1_3-3.pdf '''

# sets how many devices in location; set to 100%
Dinit = 1
NX = 1000
NY = 1000
generations = 50

# Transmission Threshold (TR) is the probability which a node transforms from state V to other states
TR = .5

# Refer to page 5 of probability parameters & page 7 for simulation
MobilePhone = namedtuple('Mobile', 'STATE D HV VI VE EI IQ QI ER ID DR VR')
tnew = []
start = time. time()


def printf(format, *args):
    sys.stdout.write(format % args)


def showCellPhones(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if tnew[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif tnew[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif tnew[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Infectious State (Red)
            elif tnew[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif tnew[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Recovered State (Green)
            elif tnew[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Quiet State (White)
            elif tnew[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', tnew[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', tnew[i][j].STATE)
        printf("\n")
    printf('\x1b[2J\x1b[H')

    time.sleep(1)


def showCellPhones_persist(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if tnew[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif tnew[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif tnew[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Infectious State (Red)
            elif tnew[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif tnew[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Recovered State (Green)
            elif tnew[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Quiet State (White)
            elif tnew[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', tnew[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', tnew[i][j].STATE)
        printf("\n")


for i in range(NY):
    new = []
    for j in range(NX):
        # Instantiate nodes with the following:
        # STATE is empty, distribution is random, prob from Healthy to Vulnerable,
        Node = MobilePhone(' ', random.random(), 0.5, 0.6, 0, 0.2, 0, 0.15, 0.4, 0.5, 0.4, 1)
        new.append(Node)
    tnew.append(new)

# Create device filled Matrix
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0:
            tnew[i][j] = tnew[i][j]._replace(STATE='H')

# Infect a device in the middle of the grid */
# Constant source infected */ //	tnew[nx/2][ny/2].B = 1;
tnew[NY // 2][NX // 2] = tnew[NY // 2][NX // 2]._replace(STATE='I')  # changes center device to infected in location

# Show initial state
showCellPhones(NX, NY, tnew)

# Set all other healthy nodes to Vulnerable now 1 device is infected
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0 and tnew[i][j].STATE != 'I':
            tnew[i][j] = tnew[i][j]._replace(STATE='V')

# Show vulnerable state
showCellPhones(NX, NY, tnew)

for step in range(generations):
    t = copy.deepcopy(tnew)
    #    print(id(t),id(tnew),id(t[0]),id(tnew[0]),id(new),id(t[0][0]))
    for i in range(1, NY - 1):
        for j in range(1, NX - 1):
            # Rules of the game ################ PRIMARY CONDITIONAL CHECK ###################
            # Breaking out step 5 on page 7

            # Node x is (i,j)
            # Count number of infected neighbors (IC) around x node
            IC = 0
            if t[i + 1][j + 1].STATE == 'C':
                IC += 1
            elif t[i - 1][j + 1].STATE == 'C':
                IC += 1
            elif t[i + 1][j - 1].STATE == 'C':
                IC += 1
            elif t[i - 1][j - 1].STATE == 'C':
                IC += 1
            elif t[i - 1][j].STATE == 'C':
                IC += 1
            elif t[i][j-1].STATE == 'C':
                IC += 1
            elif t[i][j+1].STATE == 'C':
                IC += 1
            elif t[i+1][j].STATE == 'C':
                IC += 1

            # Check if x node is infected
            if t[i][j].STATE == 'I':
                # Calculate Spread Rate (SR), Resistance Rate (RR), Node Distance (D), and Beta (b) for each X node

                # Does a corner node exist?
                if 0.293 > random.random():
                    # If the state of its neighbor node y is V
                    # Check node diagonally to the upper right if it exists
                    try:
                        if t[i + 1][j + 1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i + 1][j + 1].VE > random.random():
                                    tnew[i + 1][j + 1] = tnew[i + 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i + 1][j + 1].VR > random.random():
                                    tnew[i + 1][j + 1] = tnew[i + 1][j + 1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')

                    except IndexError:
                        pass

                    # Check node diagonally to the upper left if it exists
                    try:
                        if t[i - 1][j + 1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j + 1].VE > random.random():
                                    tnew[i - 1][j + 1] = tnew[i - 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j + 1].VR > random.random():
                                    tnew[i - 1][j + 1] = tnew[i - 1][j + 1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower right if it exists
                    try:
                        if t[i + 1][j - 1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i + 1][j - 1].VE > random.random():
                                    tnew[i + 1][j - 1] = tnew[i + 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i + 1][j - 1].VR > random.random():
                                    tnew[i + 1][j - 1] = tnew[i + 1][j - 1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower left if it exists
                    try:
                        if t[i - 1][j - 1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j - 1].VE > random.random():
                                    tnew[i - 1][j - 1] = tnew[i - 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j - 1].VR > random.random():
                                    tnew[i - 1][j - 1] = tnew[i - 1][j - 1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass
                # If this, then it only checks to the left, right, above and below of x node
                else:

                    # Check node to the left if it exists
                    try:
                        if t[i - 1][j].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j].VE > random.random():
                                    tnew[i - 1][j] = tnew[i - 1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j].VR > random.random():
                                    tnew[i - 1][j] = tnew[i - 1][j]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the below if it exists
                    try:
                        if t[i][j-1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i][j-1].VE > random.random():
                                    tnew[i][j-1] = tnew[i][j-1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i][j-1].VR > random.random():
                                    tnew[i][j - 1] = tnew[i][j-1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the above if it exists
                    try:
                        if t[i][j+1].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i][j+1].VE > random.random():
                                    tnew[i][j+1] = tnew[i][j+1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i][j+1].VR > random.random():
                                    tnew[i][j + 1] = tnew[i][j+1]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the right if it exists
                    try:
                        if t[i+1][j].STATE == 'V':
                            tmax = time.time() + start
                            SR = (1/('g1' * math.pow(e, (1/tmax)))) - ((0.3 * IC) * (1/('g2' * math.pow(e, ((1/IC)+1)))))
                            RR = (1 - e) / (1 + e)
                            b = 1 / (RR * math.sqrt(2))  # should be IR / RR * sqrt(2)
                            #  and if β is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i+1][j].VE > random.random():
                                    tnew[i+1][j] = tnew[i+1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i+1][j].VR > random.random():
                                    tnew[i + 1][j] = tnew[i+1][j]._replace(STATE='R')
                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

    showCellPhones(NX, NY, tnew)

showCellPhones_persist(NX, NY, tnew)
end = time.time()
print("Total Execution Time: " + str((end - start)))
