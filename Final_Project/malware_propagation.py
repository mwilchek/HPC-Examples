from collections import namedtuple
import random
import sys
import math
import time
import copy

''' This script simulates malware propagation from bluetooth enabled devices using a Cellular Automata Model. 
For more information please go here: http://www.ijcncs.org/published/volume3/issue3/p1_3-3.pdf '''

# sets how many devices in location; set to 100%
Dinit = 1
NX = 50
NY = 50
generations = 50  # also will be treated as t for step 6

# Transmission Threshold (TR) is the probability which a node transforms from state V to other states
TR = .5
# End of step 5 has logic if mobile device is charged or is being charged (not included)
phone_power = 100
SR = -1

# Refer to page 5 of probability parameters & page 7 for simulation
MobilePhone = namedtuple('Mobile', 'STATE D HV VI VE EI IQ QI ER ID DR VR')
tnew = []
start = time.time()


def printf(format, *args):
    sys.stdout.write(format % args)


def showCellPhones(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if tnew[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif tnew[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif tnew[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Infectious State (Red)
            elif tnew[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif tnew[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Recovered State (Green)
            elif tnew[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Quiet State (White)
            elif tnew[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', tnew[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', tnew[i][j].STATE)
        printf("\n")
    printf('\x1b[2J\x1b[H')

    time.sleep(1)


def showCellPhones_persist(nx, ny, t):
    for i in range(ny):
        for j in range(nx):
            # If node is in Health State (Beige)
            if tnew[i][j].STATE == 'H':
                printf('\033[46m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Vulnerable State (Violet)
            elif tnew[i][j].STATE == 'V':
                printf('\033[45m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Exposed State (Yellow)
            elif tnew[i][j].STATE == 'E':
                printf('\033[43m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Infectious State (Red)
            elif tnew[i][j].STATE == 'I':
                printf('\033[100m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Diagnosed State (Blue)
            elif tnew[i][j].STATE == 'D':
                printf('\033[44m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Recovered State (Green)
            elif tnew[i][j].STATE == 'R':
                printf('\033[42m'"%c "'\033[0m', tnew[i][j].STATE)

            # If node is in Quiet State (White)
            elif tnew[i][j].STATE == 'Q':
                printf('\033[47m'"%c "'\033[0m', tnew[i][j].STATE)

            else:
                printf('\033[0m'"%c "'\033[0m', tnew[i][j].STATE)
        printf("\n")


for i in range(NY):
    new = []
    for j in range(NX):
        # Instantiate nodes with the following:
        # STATE is empty, distribution is random, prob from Healthy to Vulnerable,

        # ('Mobile',                                HV   VI  VE   EI  IQ  QI   ER   ID   DR  VR')
        # Initial parameters (' ', random.random(), 0.5, 0.6, 0, 0.2, 0, 0.15, 0.4, 0.5, 0.4, 1)
        Node = MobilePhone(' ', random.random(),    0.5, 0.8, 0, 0.8, 0.2, 0.8, 0.02, 0.1, 0.4, 0.1)

        new.append(Node)
    tnew.append(new)

# Create device filled Matrix
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0:
            tnew[i][j] = tnew[i][j]._replace(STATE='H')

# Infect a device in the middle of the grid */
# Constant source infected */ //	tnew[nx/2][ny/2].B = 1;
tnew[NY // 2][NX // 2] = tnew[NY // 2][NX // 2]._replace(STATE='I')  # changes center device to infected in location

# Show initial state
showCellPhones(NX, NY, tnew)

# Set all other healthy nodes to Vulnerable now 1 device is infected
for i in range(1, NY - 1):
    for j in range(1, NX - 1):
        if Dinit - tnew[i][j].D > 0 and tnew[i][j].STATE != 'I':
            tnew[i][j] = tnew[i][j]._replace(STATE='V')

# Show vulnerable state
showCellPhones(NX, NY, tnew)

for step in range(generations):
    print("Starting Round: " + str(step))
    t = copy.deepcopy(tnew)
    #    print(id(t),id(tnew),id(t[0]),id(tnew[0]),id(new),id(t[0][0]))
    for i in range(1, NY - 1):
        for j in range(1, NX - 1):
            # Rules of the game ################ PRIMARY CONDITIONAL CHECK ###################
            # Breaking out step 5 on page 7

            # Node x is (i,j)
            # Count number of infected neighbors (IC) around x node
            IC = 0
            if t[i + 1][j + 1].STATE == 'I':
                IC += 1
            elif t[i - 1][j + 1].STATE == 'I':
                IC += 1
            elif t[i + 1][j - 1].STATE == 'I':
                IC += 1
            elif t[i - 1][j - 1].STATE == 'I':
                IC += 1
            elif t[i - 1][j].STATE == 'I':
                IC += 1
            elif t[i][j-1].STATE == 'I':
                IC += 1
            elif t[i][j+1].STATE == 'I':
                IC += 1
            elif t[i+1][j].STATE == 'I':
                IC += 1

            # Check if node x is Exposed
            if t[i][j].STATE == 'E':
                # Check if node x changes from E to R with probability of ER
                if tnew[i][j].ER > random.random():
                    tnew[i][j] = tnew[i][j]._replace(STATE='R')
                # Or node x changes from E to I with probability of EI + ER
                elif tnew[i][j].EI + tnew[i][j].ER > random.random():
                    tnew[i][j] = tnew[i][j]._replace(STATE='I')

            # Check if node x is Diagnosed
            if t[i][j].STATE == 'D':
                # Check if node x changes from D to R with probability of DR
                if tnew[i][j].DR > random.random():
                    tnew[i][j] = tnew[i][j]._replace(STATE='R')

            # Check if x node is infected
            if t[i][j].STATE == 'I':
                # Calculate Spread Rate (SR), Resistance Rate (RR), Node Distance (D), and Beta (b) for each X node

                # Does a corner node exist?
                if 0.293 > random.random():
                    # If the state of its neighbor node y is V
                    # Check node diagonally to the upper right if it exists
                    try:
                        if t[i + 1][j + 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha*tmax))) / (1 + math.pow(math.e, (alpha*tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i + 1][j + 1].VE > random.random():
                                    tnew[i + 1][j + 1] = tnew[i + 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i + 1][j + 1].VR > random.random():
                                    tnew[i + 1][j + 1] = tnew[i + 1][j + 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i+1][j + 1] = tnew[i+1][j + 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')

                    except IndexError:
                        pass

                    # Check node diagonally to the upper left if it exists
                    try:
                        if t[i - 1][j + 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j + 1].VE > random.random():
                                    tnew[i - 1][j + 1] = tnew[i - 1][j + 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j + 1].VR > random.random():
                                    tnew[i - 1][j + 1] = tnew[i - 1][j + 1]._replace(STATE='R')

                                # Added
                                else:
                                    tnew[i-1][j + 1] = tnew[i-1][j + 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower right if it exists
                    try:
                        if t[i + 1][j - 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i + 1][j - 1].VE > random.random():
                                    tnew[i + 1][j - 1] = tnew[i + 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i + 1][j - 1].VR > random.random():
                                    tnew[i + 1][j - 1] = tnew[i + 1][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i + 1][j - 1] = tnew[i + 1][j - 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node diagonally to the lower left if it exists
                    try:
                        if t[i - 1][j - 1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j - 1].VE > random.random():
                                    tnew[i - 1][j - 1] = tnew[i - 1][j - 1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j - 1].VR > random.random():
                                    tnew[i - 1][j - 1] = tnew[i - 1][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i-1][j - 1] = tnew[i-1][j - 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass
                # If this, then it only checks to the left, right, above and below of x node
                else:

                    # Check node to the left if it exists
                    try:
                        if t[i - 1][j].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i - 1][j].VE > random.random():
                                    tnew[i - 1][j] = tnew[i - 1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i - 1][j].VR > random.random():
                                    tnew[i - 1][j] = tnew[i - 1][j]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i-1][j] = tnew[i-1][j]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the below if it exists
                    try:
                        if t[i][j-1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i][j-1].VE > random.random():
                                    tnew[i][j-1] = tnew[i][j-1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i][j-1].VR > random.random():
                                    tnew[i][j - 1] = tnew[i][j - 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i][j - 1] = tnew[i][j - 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the above if it exists
                    try:
                        if t[i][j+1].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i][j+1].VE > random.random():
                                    tnew[i][j+1] = tnew[i][j+1]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i][j + 1].VR > random.random():
                                    tnew[i][j + 1] = tnew[i][j + 1]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i][j + 1] = tnew[i][j + 1]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

                    # Check node to the right if it exists
                    try:
                        if t[i+1][j].STATE == 'V':
                            tmax = int(step)

                            # Formula for SR found on page 6, g1 and g2 are user defined constants
                            g1 = random.randint(1, 10)
                            g2 = random.randint(1, 10)
                            # try:
                            #     SR = (1 / (g1 * math.pow(math.e, (1 / tmax)))) - (
                            #                 (0.3 * IC) * (1 / (g2 * math.pow(math.e, ((1 / IC) + 1)))))
                            # except ZeroDivisionError:
                            #     SR = -1

                            # Formula for RR found on page 6. alpha can be user defined
                            alpha = random.random()
                            RR = (1 - math.pow(math.e, (alpha * tmax))) / (1 + math.pow(math.e, (alpha * tmax)))

                            # should be IR / RR * sqrt(2); but IR is not defined so SR is used
                            try:
                                b = SR / (RR * math.sqrt(2))
                            except ZeroDivisionError:
                                # If RR is 0 set Beta to 1; the device has no resistance and shall change
                                b = 1

                            #  and if Î² is greater than TR
                            if b > TR:
                                # node y changes its state from V to E with probability of VE
                                if tnew[i+1][j].VE > random.random():
                                    tnew[i+1][j] = tnew[i+1][j]._replace(STATE='E')
                                # Otherwise, node y remains in the previous state.
                                else:
                                    pass

                            if SR < 0 or RR > 0.01:
                                # node y changes its state from V to R with probability of VR. At the same time, node x
                                # transforms its state from I to D with probability of ID
                                if tnew[i+1][j].VR > random.random():
                                    tnew[i + 1][j] = tnew[i+1][j]._replace(STATE='R')

                                # Added to spread malware
                                else:
                                    tnew[i + 1][j] = tnew[i + 1][j]._replace(STATE='I')

                                if tnew[i][j].ID > random.random():
                                    tnew[i][j] = tnew[i][j]._replace(STATE='D')
                    except IndexError:
                        pass

    # Increase time += 1 for each generation as specified in step 6 on page 7
    showCellPhones(NX, NY, tnew)

showCellPhones_persist(NX, NY, tnew)
end = time.time()
print("Total Execution Time: " + str((end - start)))
